"""
Script to clean generated training data by removing prompt prefixes from user_message fields.

This script processes JSON files generated by generate_data.py and removes various
prefixes that were added during generation, keeping only the actual user message content.
"""

import json
import os
import re
from typing import Dict, List
from pathlib import Path


class DataCleaner:
    """Clean generated instruction hierarchy data"""

    # Patterns to remove from user_message fields
    PATTERNS_TO_REMOVE = [
        # Exact prefix matches (case-insensitive)
        r'^Adversarial user message:\s*',
        r'^User message:\s*',

        # Multi-line prefix patterns
        r'^Sure,\s+here\'s\s+an?\s+adversarial\s+user\s+message.*?:\s*\n*',
        r'^Sure,\s+here\'s\s+a\s+crafted\s+message.*?:\s*\n*',
        r'^Here\'s\s+an?\s+adversarial\s+user\s+message.*?:\s*\n*',
        r'^Here\'s\s+a\s+user\s+message.*?:\s*\n*',

        # Remove leading quotes that were part of the wrapper
        r'^["\']',
        r'["\']$',
    ]

    def __init__(self, data_dir: str = "./instruction_hierarchy_data"):
        """
        Initialize the data cleaner

        Args:
            data_dir: Directory containing generated JSON files
        """
        self.data_dir = Path(data_dir)
        if not self.data_dir.exists():
            raise ValueError(f"Data directory does not exist: {data_dir}")

    def clean_user_message(self, message: str) -> str:
        """
        Clean a single user message by removing generation artifacts

        Args:
            message: Original user message with potential prefixes

        Returns:
            Cleaned user message
        """
        cleaned = message.strip()

        # Apply each pattern in order
        for pattern in self.PATTERNS_TO_REMOVE:
            cleaned = re.sub(pattern, '', cleaned, flags=re.IGNORECASE | re.DOTALL)
            cleaned = cleaned.strip()

        # Remove any remaining leading/trailing quotes
        if cleaned.startswith('"') and cleaned.endswith('"'):
            cleaned = cleaned[1:-1].strip()

        return cleaned

    def clean_example(self, example: Dict) -> Dict:
        """
        Clean a single training example

        Args:
            example: Training example dictionary

        Returns:
            Cleaned example
        """
        if 'user_message' in example:
            example['user_message'] = self.clean_user_message(example['user_message'])

        return example

    def clean_file(self, filepath: Path, output_dir: Path = None, dry_run: bool = False) -> Dict:
        """
        Clean a single JSON file

        Args:
            filepath: Path to JSON file
            output_dir: Optional output directory (defaults to overwriting original)
            dry_run: If True, don't write changes

        Returns:
            Statistics about cleaning
        """
        print(f"\nProcessing: {filepath.name}")

        # Load data
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            print(f"  ✗ Error: Invalid JSON - {e}")
            return {'total': 0, 'cleaned': 0, 'unchanged': 0, 'file': filepath.name}

        # Validate data is a list
        if not isinstance(data, list):
            print(f"  ✗ Skipping: Not a list of examples")
            return {'total': 0, 'cleaned': 0, 'unchanged': 0, 'file': filepath.name}

        # Track statistics
        stats = {
            'total': len(data),
            'cleaned': 0,
            'unchanged': 0,
            'file': filepath.name
        }

        # Clean each example
        cleaned_data = []
        for example in data:
            # Skip non-dict entries
            if not isinstance(example, dict):
                cleaned_data.append(example)
                stats['unchanged'] += 1
                continue

            original_message = example.get('user_message', '')
            cleaned_example = self.clean_example(example.copy())
            cleaned_message = cleaned_example.get('user_message', '')

            if original_message != cleaned_message:
                stats['cleaned'] += 1
            else:
                stats['unchanged'] += 1

            cleaned_data.append(cleaned_example)

        # Save cleaned data
        if not dry_run:
            if output_dir:
                output_path = output_dir / filepath.name
            else:
                output_path = filepath

            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(cleaned_data, f, indent=2, ensure_ascii=False)

            print(f"  ✓ Saved to: {output_path}")
        else:
            print(f"  [DRY RUN] Would save to: {output_dir / filepath.name if output_dir else filepath}")

        print(f"  Total examples: {stats['total']}")
        print(f"  Cleaned: {stats['cleaned']}")
        print(f"  Unchanged: {stats['unchanged']}")

        return stats

    def clean_all(self, output_dir: str = None, dry_run: bool = False) -> List[Dict]:
        """
        Clean all JSON files in the data directory

        Args:
            output_dir: Optional output directory (defaults to overwriting originals)
            dry_run: If True, don't write changes

        Returns:
            List of statistics for each file
        """
        print("=" * 60)
        print("DATA CLEANING PIPELINE")
        print("=" * 60)
        print(f"Data directory: {self.data_dir}")

        # Create output directory if needed
        if output_dir:
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            print(f"Output directory: {output_path}")
        else:
            output_path = None
            print("Mode: In-place cleaning (overwriting originals)")

        if dry_run:
            print("DRY RUN MODE: No files will be modified")

        # Find all JSON files
        json_files = sorted(self.data_dir.glob("*.json"))

        if not json_files:
            print("\n✗ No JSON files found in data directory")
            return []

        print(f"\nFound {len(json_files)} JSON files to process")

        # Clean each file
        all_stats = []
        for filepath in json_files:
            stats = self.clean_file(filepath, output_path, dry_run)
            all_stats.append(stats)

        # Print summary
        print("\n" + "=" * 60)
        print("CLEANING COMPLETE")
        print("=" * 60)

        total_examples = sum(s['total'] for s in all_stats)
        total_cleaned = sum(s['cleaned'] for s in all_stats)
        total_unchanged = sum(s['unchanged'] for s in all_stats)

        print(f"\nTotal files processed: {len(all_stats)}")
        print(f"Total examples: {total_examples}")
        print(f"Examples cleaned: {total_cleaned} ({100*total_cleaned/total_examples:.1f}%)")
        print(f"Examples unchanged: {total_unchanged} ({100*total_unchanged/total_examples:.1f}%)")

        return all_stats

    def preview_changes(self, num_examples: int = 5):
        """
        Preview what changes will be made without writing files

        Args:
            num_examples: Number of example changes to show
        """
        print("=" * 60)
        print("PREVIEW MODE - Showing example changes")
        print("=" * 60)

        json_files = sorted(self.data_dir.glob("*.json"))

        if not json_files:
            print("\n✗ No JSON files found")
            return

        examples_shown = 0

        for filepath in json_files:
            if examples_shown >= num_examples:
                break

            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)

                # Handle case where data might not be a list
                if not isinstance(data, list):
                    print(f"\n✗ Skipping {filepath.name} - not a list of examples")
                    continue

                for example in data:
                    if examples_shown >= num_examples:
                        break

                    # Ensure example is a dict
                    if not isinstance(example, dict):
                        continue

                    original = example.get('user_message', '')
                    cleaned = self.clean_user_message(original)

                    if original != cleaned:
                        print(f"\n[Example {examples_shown + 1}] File: {filepath.name}")
                        print(f"Type: {example.get('type', 'unknown')}")
                        print(f"\nORIGINAL:")
                        print(f"  {original[:200]}{'...' if len(original) > 200 else ''}")
                        print(f"\nCLEANED:")
                        print(f"  {cleaned[:200]}{'...' if len(cleaned) > 200 else ''}")
                        print("-" * 60)
                        examples_shown += 1

            except json.JSONDecodeError as e:
                print(f"\n✗ Error reading {filepath.name}: {e}")
                continue

        if examples_shown == 0:
            print("\n✓ No changes needed - all messages are already clean!")


def main():
    """
    Main function to run data cleaning
    """
    import argparse

    parser = argparse.ArgumentParser(
        description="Clean generated instruction hierarchy training data"
    )
    parser.add_argument(
        '--data-dir',
        type=str,
        default='./instruction_hierarchy_data',
        help='Directory containing JSON files to clean (default: ./instruction_hierarchy_data)'
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default=None,
        help='Output directory for cleaned files (default: overwrite originals)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview changes without writing files'
    )
    parser.add_argument(
        '--preview',
        action='store_true',
        help='Show example changes before cleaning'
    )
    parser.add_argument(
        '--preview-count',
        type=int,
        default=5,
        help='Number of examples to show in preview (default: 5)'
    )

    args = parser.parse_args()

    # Initialize cleaner
    try:
        cleaner = DataCleaner(data_dir=args.data_dir)
    except ValueError as e:
        print(f"Error: {e}")
        return

    # Preview mode
    if args.preview:
        cleaner.preview_changes(num_examples=args.preview_count)
        print("\nTo clean the data, run without --preview flag")
        return

    # Clean data
    cleaner.clean_all(output_dir=args.output_dir, dry_run=args.dry_run)

    if args.dry_run:
        print("\nThis was a dry run. To actually clean the data, run without --dry-run flag")


if __name__ == "__main__":
    main()
